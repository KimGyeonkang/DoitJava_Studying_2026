## 스레드

- 스레드란? 프로그램이 CPU에서 실행하는 작업 단위
하나의 단위로만 실행할 수도 있고(__단일스레딩__), 여러 단위를 동시에 수행할 수도 있음(__멀티스레딩__)
- 프로세스와 스레드: 프로그램을 실행한 뒤 메모리에 할당된 상태를 __프로세스__ 라고 하며, 프로세스가 CPU를 점유해 명령이 실행되는 단위를 **스레드**라 할 수 있겠다!
-> 웹 페이지에서 파일을 다운로드 받으며 텍스트를 입력하는 게 작업이 동시에 처리되는 모습이다? 스레드(CPU 단위)는 별도지만 실제로는 같은 프로세스(메모리 단위) 안에서 수행되는 것! 즉 _두 개 이상의 작업 명령(스레드)은 각자 실행될 뿐인데 사용자(클라이언트)에게는 여러 작업들이 동시에 처리되는 걸로 느껴지는 것_
-> **멀티 스레딩** : 한 프로세스 안에서 복수의 스레드가 독립 실행되는 것.
- __동기화__ : 멀티스레딩 상황에서 같은 자원(공유 자원)에 스레드 하나만 접근할 수 있도록 순서를 제어하는 것.
-> 멀티 스레딩 상황에서, 복수의 스레드가 번갈아 실행되면서 공유 자원이 발생함(같은 자원을 공유함을 의미). 이때 발생하는 스레드 간 경쟁관계를 적절하게 제어하지 못하면 프로그램에 문제가 발생할 수 있다.
-> 은행 앱이나 예매 사이트처럼 많은 사람이 동시에 이용하는 프로그램에서, 그 많은 작업이 동시에 발생하고 통제가 되지 않는다면 문제가 발생하지 않을까? 따라서 **적절한 동기화가 필요한 것!**
- 스레드 스케줄링: 스레드가 중앙 처리 장치를 사용하는 순서를 정하는 것으로, 운영체제에서 매우 중요한 정책 알고리즘이라고 함.
1) 비선점형: 한 번 CPU 공간을 할당받은 스레드가 이후 운영체제의 통제 없이 계속 해당 공간을 이용.
2) 선점형: 이미 CPU 공간을 할당받은 스레드를 운영체제가 강제로 쫓아내고 다른 작업 단위를 할당할 수 있음. 종류에는 우선순위 높은 스레드 우선 할당(우선순위 기반), 사용 시간을 일정하게 배분하는 방식(라운드로빈), 수행 시간이 가장 짧은 스레드 우선 할당(SJF; 최단 작업 시간 우선)

## Thread 클래스와 각종 메서드
- 자바에서 스레드를 구현하는 방법에는 두 가지가 있다. 1) java.lang 패키지의 Thread 클래스를 하위 클래스가 상속받거나, 2) Runnable 인터페이스를 구현받기(자바는 복수 상속을 허용하지 않으므로, 클래스가 이미 다른 클래스를 상속받아 Thread 클래스를 extends할 수 없을 경우)
-> 1)의 경우 Thread 클래스의 run() 메서드 구현부에 스레드가 실행될 때 수행할 코드를 입력, 2)의 경우 Runnable 인터페이스의 run() 추상 메서드를 직접 구현, 이후는 1)과 동일.
- 스레드에는 어떤 상태가 있을까?
1) Runnable 상태: 스레드 실행 가능
2) Run 상태: 스레드가 CPU를 점유하고 동작(스케줄링 알고리즘에 따라 시간 배분이나 우선순위 등을 기준으로 순서 제어)
3) Dead 상태: 스레드가 할 일을 마침
4) Not Runnable 상태: 몇 가지 조건이 갖춰졌을 때, CPU를 점유할 수 없는 상태가 됨
- Thread 클래스의 주요 메서드를 알아보자.
1) sleep(): 일정 시간 동안 스레드가 CPU를 차지할 수 없는 상태(Not Runnable)가 되도록 함. 가령 sleep(1)은 1/1000초 동안 스레드가 CPU를 점유할 수 없도록 제어함. 이 시간이 지나면 실행 가능한 Runnable 상태가 됨. 참고) sleep(1000)은 1초 간 Not Runnable 상태.
2) interrupt(): 스레드가 하던 일을 멈추도록 지시함. InterruptedException 예외 처리 동반 필요
3) join(): 두 개의 스레드가 실행 가능할 때 하나의 스레드가 다른 스레드의 결과를 참조하도록 함.

## 동기화

복수의 스레드가 실행될 때 공유 자원에 대한 접근을 적절히 제어하는 **동기화** 가 중요함! 가령, 동시에 여러 작업이 진행되는 은행 앱에서 가족 두 명이 하나의 통장을 공유한다고 가정해본다. 기존 통장 잔액이 20000원인 상황에서 가족 한 명의 입금 작업(+1000원)이 미처 다 수행되기도 전에 다른 가족의 출금 작업(-3000원)이 개입해버린다면? 입금이 끝나지 않은 상태에서 출금 작업이 실행되고 결괏값이 예상 잔액인 18000원이 아닌 값이 될 수 있다(입금 결과와 관계없이 17000원이 된다든지).

-> 이런 결과를 방지하고자 필요한 게, 하나의 스레드가 작업을 수행하는 동안 다른 스레드가 같은 공간에 접근하지 못하도록 하는 작업 즉 **동기화**

-> 자바에서는 synchronaized 예약어를 통해 동기화를 구현할 수 있다. 메서드에 해당 예약어를 추가해, 하나의 스레드가 메서드를 수행하는 동안 다른 스레드가 접근하지 못하도록, _실행 중인 메서드가 있는 객체를 잠그도록 처리(lock을 건다)_
> synchronaized -> "먼저 들어온 작업부터 처리할 테니까 그동안 얌전히 기다리고 있어! 앞에 것 끝나면 불러줄게." -> 이렇게 여러 스레드의 **순차 처리**가 구현됨.

## 멀티스레딩 중 동기화 과정에 대해서 정리해봤다. 그렇다면 이런 경우도 생각해볼 수 있다. "만약 공유 자원이 충분하지 않으면 어쩌죠?"
예를 들어 대학 수강 신청 시스템에서 갑자기 많은 사용자가 몰려 몇몇 학생의 컴퓨터가 접근 권한을 제대로 받지 못하 수강신청을 망친다면? 이런 불상사를 방지하려면, 자원을 제대로 할당받지 못하는 스레드에 대한 적절한 처리가 필요하다.
-> 이를 자바에서는 '**공유 자원의 스레드 대기와 알림**' 구현을 통해 해결한다고 함. 대표적으로 Object 클래스의 wait()와 notify() 메서드

> wait(): "미안하지만 지금은 너희가 들어갈 공간이 없어. _일단 대기번호표 뽑고 기다리고 있어!_ (다른 스레드가 자원을 사용 후 반환해 다음 사용 가능한 상태가 될 때까지 기다리게 함)" 

> notify(): "대기번호 1번, 한 자리 비었으니까 이제 들어오면 돼!( _알림으로 대기 중인 스레드를 깨움_ )" 

> notifyAll(): "일단 자리 하나는 비었어. 그런데 _일일이 한 명씩 부르기 귀찮으니까 너희끼리 알아서 차지해~_ (대기 중인 모든 스레드에게 알림. 대기 중인 스레드 하나에만 통지하는 notify()의 한계를 보완하기 위해 사용. 다만 이쪽은 Runnable 상태인 스레드끼리 경쟁하게 되며, 경쟁에서 밀린 스레드는 wait() 스레드에 의해 대기 상태로 다시 넘어가는 과정을 반복함)"

### Thread safe하다?
하나의 프로그램에서 여러 스레드가 동시에 접근해도 그 결과(자료의 정확성, 일관성, 예측 가능한 결과)가 안정적으로 보장됨을 의미.
